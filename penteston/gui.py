import base64
import io
import json
import time
import tkinter as tk
import tkinter.simpledialog
from tkinter import *
from tkinter import filedialog, ttk

import PIL.ImageTk
import pyscreenshot as ImageGrab
from ewmh import EWMH
from jinja2 import Environment, FileSystemLoader
from markdown2 import Markdown
from tkhtmlview import HTMLLabel

from penteston.onenote import OneNoteAPI


class OneNoteScreenGUI:
    ewmh = EWMH()
    winname = None
    l = None
    window = None
    im = None
    selpage = None

    def __init__(self, ona):
        self.ona = ona
        file_loader = FileSystemLoader('templates')
        self.env = Environment(loader=file_loader)

    def getWindowFrame(self, client):
        frame = client
        while frame.query_tree().parent != self.ewmh.root:
            frame = frame.query_tree().parent
        return frame

    def screenshot(self, name):
        im = None
        if (name == "fullscreen"):
            print("Fullscreen...")
            self.im = ImageGrab.grab()
            print(self.im)
        else:
            print("self.selfwin")
            f = self.getWindowFrame(self.selwin)
            self.ewmh.setActiveWindow(self.selwin)
            self.ewmh.display.flush()
            # wait for the window to actually be on the screen if it was minimized before.
            for i in range(1, 100):
                if self.selwin == self.ewmh.getActiveWindow():
                    break
                time.sleep(.1)
            geo = f.get_geometry()
            self.im = ImageGrab.grab(
                bbox=(geo.x, geo.y, geo.x+geo.width, geo.y+geo.height))
        return self.im

    def screenShotCallback(self):
        self.imc = self.screenshot(self.winname.get()).copy()
        self.imc.thumbnail((500, 500))
        photo = PIL.ImageTk.PhotoImage(self.imc)
        self.l.configure(image=photo)
        self.l.image = photo
        self.window.lift()
        self.window.attributes('-topmost', True)
        self.window.attributes('-topmost', False)

    def updateMenu(self, client):
        self.selwin = client
        self.winname.set(client.get_wm_class()[1])

    def updateNotebook(self, nb):
        self.selnotebook = nb
        self.notebook.set(nb[0])
        self.populateSection()
        self.populatePages()
        print(nb)

    def updateSection(self, s):
        self.selsection = s
        self.section.set(s[0])
        self.populatePages()

    def updatePage(self, p):
        print(p)
        self.selpage = p
        print(self.ona._pageIds(p[1]))

    def populatePages(self):
        if self.selsection[1]:
            pages = ona._pagesSID(self.selsection[1])
        else:
            pages = []
        menu = self.pageOption['menu']
        menu.delete(0, 'end')
        if len(pages) > 0:
            for p in pages:
                name = p[0]
                menu.add_command(
                    label=name, command=lambda p=p: self.updatePage(p))
            self.page.set(pages[0][0])
            self.selpage = pages[0]
            print("#$#$# Markdown:")
            md=self.ona._getDataIdMarkdown(self.selpage[1],"summary")
            print(md)
            self.inputexec.delete(1.0, tk.END)
            self.inputexec.insert(tk.END, md)
        else:
            name = ""
            menu.add_command(label=name)
            self.selpage = ("", None)

    def populateSection(self):
        sections = ona._sections(self.selnotebook[1])
        menu = self.sectionOption['menu']
        menu.delete(0, 'end')
        if len(sections) > 0:
            for s in sections:
                name = s[0]
                menu.add_command(
                    label=name, command=lambda s=s: self.updateSection(s))
            self.section.set(sections[0][0])
            self.selsection = sections[0]
        else:
            name = ""
            menu.add_command(label=name)
            self.selsection = ("", None)

    def appendSectionCallback(self):
        ids = self.ona._pageIds(self.selpage[1])
        dataid = self.ona._getIdForDataId(ids, self.findingSection.get())
        print(dataid)
        if dataid and self.selpage and self.selpage[1]:
            md2html = Markdown()
            acontent = md2html.convert(self.inputeditora.get("1.0", END))
            bcontent = md2html.convert(self.inputeditorb.get("1.0", END))
            buffered = io.BytesIO()
            self.imc.save(buffered, format="PNG")
            buffered.seek(0)
            self.ona._updateImgMultipart(
                self.selpage[1], dataid, "append", acontent, bcontent, buffered)
            buffered = io.BytesIO()
            self.imc.save(buffered, format="PNG")
            buffered.seek(0)
            self.ona._updateFileMultipart(
                self.selpage[1], dataid, "append", "", "", "screenshot.png", "image/png", buffered)

    def img_to_base64_str(self, img):
        """
        https://stackoverflow.com/a/61114178
        """
        buffered = io.BytesIO()
        img.save(buffered, format="PNG")
        buffered.seek(0)
        img_byte = buffered.getvalue()
        img_str = "data:image/png;base64," + \
            base64.b64encode(img_byte).decode()
        return img_str

    def img_to_bytes(self, img):
        """
        https://stackoverflow.com/a/61114178
        """
        buffered = io.BytesIO()
        img.save(buffered, format="PNG")
        buffered.seek(0)
        img_byte = buffered.getvalue()
        return img_byte

    def buildDescPanel(self):
        OptionList = [
            "recon",
            "foothold",
            "user",
            "root",
            "tools",
            "appendix"
        ]
        self.findingSection = tk.StringVar(self.rframe)
        self.findingSection.set(OptionList[0])
        self.findingOption = tk.OptionMenu(
            self.rframe, self.findingSection, *OptionList)
        self.findingOption.grid(row=0, column=0, padx=5, pady=5)

        self.inputeditora = tk.Text(self.rframe, height=2)
        self.inputeditora.grid(row=1, column=0, padx=5,
                               pady=5, sticky=(N, S, E, W))

        self.inputeditorb = tk.Text(self.rframe)
        self.inputeditorb.grid(row=2, column=0, padx=5,
                               pady=5, sticky=(N, S, E, W))

        b = tk.Button(self.rframe, text="Append",
                      command=self.appendSectionCallback)
        b.grid(row=3, column=0, padx=5, pady=5)

        self.rframe.columnconfigure(0, weight=1)
        self.rframe.rowconfigure(0, weight=0)
        self.rframe.rowconfigure(1, weight=0)
        self.rframe.rowconfigure(2, weight=1)
        self.rframe.rowconfigure(3, weight=0)

        #self.outputbox = HTMLLabel(bframe, background="white", html="<h1>Welcome</h1>")
        #self.outputbox.grid(row=0,columnspan=2,padx=5,pady=5,sticky=(N, S, E, W))
        #bframe.columnconfigure(0, weight=1)

    def buildScreenShotPanel(self):
        tk.Label(self.lframe, text="Screenshot Image").grid(
            row=0, column=0, padx=5, pady=5, sticky=(N, S, E, W))
        self.l = tk.Label(self.lframe)
        imc = self.screenshot("fullscreen").copy()
        imc.thumbnail((500, 500))
        photo = PIL.ImageTk.PhotoImage(imc)
        self.l.configure(image=photo)
        self.l.image = photo

        self.l.grid(row=1, column=0, padx=5, pady=5, sticky=(N, S, E, W))
        self.lframe.columnconfigure(0, weight=1)
        self.lframe.rowconfigure(1, weight=1)

        screen = tk.Frame(self.lframe, width=180, height=185)

        self.winname = tk.StringVar(screen)
        self.selwin = None
        w = tk.OptionMenu(screen, self.winname, "fullscreen")
        w.grid(row=0, column=0, padx=5, pady=5)

        menu = w['menu']
        menu.delete(0, 'end')
        name = "fullscreen"
        menu.add_command(
            label=name, command=lambda name=name: self.winname.set(name))

        for client in self.ewmh.getClientList():
            name = client.get_wm_class()[1]
            menu.add_command(
                label=name, command=lambda client=client: self.updateMenu(client))
        self.winname.set("fullscreen")

        b = tk.Button(screen, text="Screenshot",
                      command=self.screenShotCallback)
        b.grid(row=0, column=1, padx=5, pady=5)

        screen.grid(row=2, column=0, padx=5, pady=5)

    def createPageCallback(self):
        answer = tk.simpledialog.askstring("Create Page", "Page Name?",
                                           parent=self.window)
        print(answer)
        if answer:
            template = self.env.get_template("template.html")
            body = template.render(title=answer, me=self.me)
            pid = self.ona._createPage(self.selsection[1], body)
            print("Created: %s" % pid)
        self.populateSection()
        self.populatePages()

    def nmapCallback(self):
        filename = filedialog.askopenfilename(
            title="Select a Nmap XML File",
            filetypes=(("XML files",
                        "*.xml*"),
                       ("all files",
                        "*.*")))
        print(filename)
        print(self.selpage)
        print(self.selpage[1])
        if filename and self.selpage and self.selpage[1]:
            template = self.env.get_template("nmapservice.html")
            atemplate = self.env.get_template("nmap-a.html")
            btemplate = self.env.get_template("nmap-b.html")
            ids = self.ona._pageIds(self.selpage[1])
            dataid = self.ona._getIdForDataId(ids, "nmap-service-output")
            rawdataid = self.ona._getIdForDataId(ids, "appendix")
            if dataid:
                print("updating... %s" % dataid)
                self.ona._nmap(
                    self.selpage[1], dataid, rawdataid, template, atemplate, btemplate, filename)

    def buildOneNoteGUI(self):
        self.me = self.ona._me()
        self.tframe
        l = tk.Label(self.tframe, text="%s (%s)" %
                     (self.me['displayName'], self.me['userPrincipalName']))
        l.grid(row=0, column=0, padx=5, pady=5)

        self.notebook = tk.StringVar(self.tframe)
        w = tk.OptionMenu(self.tframe, self.notebook, "")
        w.grid(row=1, column=0, padx=5, pady=5)

        menu = w['menu']
        menu.delete(0, 'end')
        nb = self.ona._notebooks()
        for n in nb:
            name = n[0]
            menu.add_command(
                label=name, command=lambda n=n: self.updateNotebook(n))
        self.notebook.set(nb[0][0])
        self.selnotebook = nb[0]

        self.section = tk.StringVar(self.tframe)
        self.sectionOption = tk.OptionMenu(self.tframe, self.section, "")
        self.sectionOption.grid(row=1, column=1, padx=5, pady=5)

        self.page = tk.StringVar(self.tframe)
        self.pageOption = tk.OptionMenu(self.tframe, self.page, "")
        self.pageOption.grid(row=1, column=2, padx=5, pady=5)

        self.populateSection()
        self.populatePages()

        b = tk.Button(self.tframe, text="New Page...",
                      command=self.createPageCallback)
        b.grid(row=1, column=3, padx=5, pady=5)

        b = tk.Button(self.tframe, text="NMap XML...",
                      command=self.nmapCallback)
        b.grid(row=1, column=4, padx=5, pady=5)

    def refreshCallback(self):
        print("#$#$# Markdown:")
        md=self.ona._getDataIdMarkdown(self.selpage[1],"summary")
        print(md)
        self.inputexec.delete(1.0, tk.END)
        self.inputexec.insert(tk.END, md)
    
    def updateCallback(self):
        ids = self.ona._pageIds(self.selpage[1])
        id=ona._getIdForDataId(ids,"summary")
        if id:
            md2html = Markdown()
            content = '<div data-id="summary">'+md2html.convert(self.inputexec.get("1.0", END))+"</div>"
            ona._updatePageSection(self.selpage[1],content,id,"replace")            

    
    def buildSummary(self):
        self.inputexec = tk.Text(self.summaryFrame,)
        self.inputexec.grid(row=0, column=0, columnspan=2,padx=5,
                               pady=5, sticky=(N, S, E, W))
        b = tk.Button(self.summaryFrame, text="Refresh",
                      command=self.refreshCallback)
        b.grid(row=1, column=1, padx=5, pady=5)
        b = tk.Button(self.summaryFrame, text="Update",
                      command=self.updateCallback)
        b.grid(row=1, column=2, padx=5, pady=5)
 
        

        
    def buildUi(self):
        self.window = tk.Tk()
        self.window.title("--xxXXxx--")
        self.window.rowconfigure(1, weight=4)
        self.window.rowconfigure(0, weight=1)
        self.window.columnconfigure(0, weight=1)
        
        self.tabControl = ttk.Notebook(self.window)
        self.tabControl.grid(row=1,column=0, padx=5, pady=5, sticky=(N,S,E,W))
        
        self.summaryFrame = tk.Frame(self.tabControl)
        self.findingFrame = tk.Frame(self.tabControl)
        
        self.tabControl.add(self.summaryFrame,text='Sumary')
        self.tabControl.add(self.findingFrame,text='Findings')
        
        self.findingFrame.columnconfigure(1, weight=4)
        self.findingFrame.columnconfigure(0, weight=1)
        
        self.lframe = tk.Frame(self.findingFrame, width=400, height=400, bg='grey')
        self.lframe.grid(row=0, column=0, padx=10, pady=5, sticky=(N, S, E, W))

        self.rframe = tk.Frame(self.findingFrame, width=650, height=400, bg='grey')
        self.rframe.grid(row=0, column=1, padx=10, pady=5, sticky=(N, S, E, W))

        self.tframe = tk.Frame(self.window, width=1050, height=200, bg='grey')
        self.tframe.grid(columnspan=2, row=0, padx=10,
                         pady=5, sticky=(N, S, E, W))

        self.buildScreenShotPanel()
        self.buildDescPanel()
        self.buildSummary()

        return self.window


if __name__ == "__main__":
    # execute only if run as a script
    ona = OneNoteAPI()
    config = json.load(open("parameters.json", "r"))

    if ona._auth(config["client_id"], config["authority"], config["scope"]):
        og = OneNoteScreenGUI(ona)
        window = og.buildUi()
        og.buildOneNoteGUI()
        window.mainloop()
