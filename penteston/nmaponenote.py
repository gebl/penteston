import argparse
import atexit
import http.client
import json
import logging
import os
import sys
import time
import lxml.html
from lxml import etree

import msal
import requests
from jinja2 import Environment, FileSystemLoader
from libnmap.parser import NmapParser
import pyperclip
import io

def _me(auth):
    graph_data = requests.get("https://graph.microsoft.com/v1.0/me",
                              headers={'Authorization': 'Bearer ' + auth['access_token']},).json()
    print("Graph API call result: %s" % json.dumps(graph_data, indent=2))
    return graph_data


def _notebook(auth, notebook):

    graph_data = requests.get("https://graph.microsoft.com/v1.0/me/onenote/notebooks",
                              headers={'Authorization': 'Bearer ' + auth['access_token']},).json()
    for i in graph_data['value']:
        if i['displayName'] == notebook:
            return i['id']
    return None


def _createSection(auth, nid, section):
    r = requests.post("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections" % (nid), headers={
                      'Authorization': 'Bearer ' + auth['access_token'], 'Content-type': 'application/json'}, data=json.dumps({"displayName": section})).json()
    sectionId = r['id']
    return sectionId


def _section(auth, nid, section):
    sectionId = None
    graph_data2 = requests.get("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections" %
                               (nid), headers={'Authorization': 'Bearer ' + auth['access_token']},).json()
    for j in graph_data2['value']:
        print(j['displayName'])
        if j['displayName'] == section:
            sectionId = j['id']
    return sectionId


def _page(auth, sid, page):
    pageId = None
    r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/sections/%s/pages" %
                     (sid), headers={'Authorization': 'Bearer ' + auth['access_token']}).json()
    for k in r['value']:
        print(k['title'])
        if k['title'] == page:
            print(k)
            pageId = k['id']
    return pageId

def _createPage(auth, sid, body):
    r = requests.post("https://graph.microsoft.com/v1.0/me/onenote/sections/%s/pages" % (sid), headers={
                      'Authorization': 'Bearer ' + auth['access_token']}, files={'Presentation': (None, body, 'text/html')}).json()
    for i in range(0,100):
        r2 = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true" %
                     (r['id']), headers={'Authorization': 'Bearer ' + auth['access_token']}).text
        if not "The specified resource ID does not exist." in r2:
            break
        time.sleep(5)
    return r['id']

def _getDataIdElement(auth,pid,id):
    r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true" %
                     (pid), headers={'Authorization': 'Bearer ' + auth['access_token']}).text
    root=etree.fromstring(r)
    return root.find('.//*[@data-id="%s"]'%id)

def _tableColumns(t):
    cols=[]
    for c in t[0]:
        cols.append(c[0].text)
    return cols

def _rowJson(cols,tr):
    row={}
    for i in range(0,len(cols)):
        row[cols[i]]=tr[i].text
    return row

def _rowUpdate(cols,tr,n):
    for i in range(0,len(cols)):
        row[cols[i]]=tr[i].text
    return row


def _rowIndex(t,m):
    res=[]
    cols=_tableColumns(t)
    for i in range(1,len(t)):
        r=_rowJson(cols,t[i])
        rowmatch=True
        for k in m:
            rowmatch=rowmatch and(r[k] == m[k])
        if rowmatch:
            res.append(i)
    return res

def _updateRow(t,m,n):
    ris=_rowIndex(t,m)
    print(ris)
    cols=_tableColumns(t)
    print(cols)
    for r in ris:
        for k in n:
            print(k)
            t[r][cols.index(k)].text=n[k]

def _tableJson(t):
    json=[]
    cols=_tableColumns(t)
    for r in t[1:]:
        json.append(_rowJson(cols,r))
    return json


def _pageIds(auth, pid):
    r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true" %
                     (pid), headers={'Authorization': 'Bearer ' + auth['access_token']}).text
    print(r)
    root=etree.fromstring(r)
    dataids=[]
    for e in root.findall('.//*[@data-id]'):
        print(e)
        if e.get("id"):
            dataids.append((e.get("id"),e.get("data-id")))
    return dataids

def _pageContent(auth,pid):
    r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content" %
                     (pid), headers={'Authorization': 'Bearer ' + auth['access_token']}).text
    return r

def _getIdForDataId(dataids,dataid):
    for d in dataids:
        if d[1]==dataid:
            return d[0]
    return None

def _updatePageSection(auth,pid,content,dataId,action):
    data=json.dumps([{"target": dataId,"action":action,"content":content}])
    r = requests.patch("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content" % (pid), headers={
                    'Authorization': 'Bearer ' + auth['access_token'],'Content-type': 'application/json'}, data=data).text
    print(r)

def _nmap(auth,pid,oid,template,args):
    report = NmapParser.parse_fromfile(args.nmapxml)
    content = template.render(report=report)
    _updatePageSection(auth,pid,content,oid,"replace")

def _createRow(items):
    tr=Element("tr")
        
def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('profile', metavar='profile',
                        type=str, help='Path to Configuration JSON')
    parser.add_argument('notebook', metavar='notebook', type=str,
                        help='OneNote Notebook to work with. Must exist.')
    parser.add_argument('section', metavar='section', type=str,
                        help='Section within OneNote Notebook to work with.')
    parser.add_argument('--pagename', metavar='page', type=str,
                        help='Path within OneNote Notebook to work with.')
    parser.add_argument('--create', default=False, action='store_true')
    parser.add_argument('--pid', action="store",default=None)
    parser.add_argument('--list', default=False, action='store_true')
    
    parser.add_argument('--pagetemplate', metavar='pageTemplate',
                        default='template.html', help='Path to jinja template to create page.')
    parser.add_argument('--nmaptemplate', metavar='nmapTemplate',
                        default='nmapservice.html', help='Path to jinja template to create nmap table.')
    parser.add_argument('--dump', default=False, action='store_true')
    parser.add_argument('--dumpids', default=False, action='store_true')
    parser.add_argument('--contentclip', default=False, action='store_true')
    parser.add_argument('--nmapxml', action="store",default=None)
    parser.add_argument('--contentid', action="store",default=None)
    parser.add_argument('--content', action="store",default=None)
    parser.add_argument('--pw', action="store",default=None)
    parser.add_argument('--pwclip', default=False, action='store_true')
    parser.add_argument('--pwall', default=False, action='store_true')
    parser.add_argument('--updatetbl', action="store",default=None)
    parser.add_argument('--updatetblid', action="store",default=None)
    parser.add_argument('--matchtbl', action="store",default=None)

    args = parser.parse_args()

    file_loader = FileSystemLoader('templates')
    env = Environment(loader=file_loader)

    cache = msal.SerializableTokenCache()

    if os.path.exists("my_cache.bin"):
        cache.deserialize(open("my_cache.bin", "r").read())
    atexit.register(lambda:
                    open("my_cache.bin", "w").write(cache.serialize()
                                                    ) if cache.has_state_changed else None
                    )

    # Optional logging
    # logging.basicConfig(level=logging.DEBUG)

    config = json.load(open(args.profile))

    # Create a preferably long-lived app instance which maintains a token cache.
    app = msal.PublicClientApplication(
        config["client_id"], authority=config["authority"],
        token_cache=cache
    )

    result = None

    accounts = app.get_accounts()
    if accounts:
        logging.info(
            "Account(s) exists in cache, probably with token too. Let's try.")
        print("Pick the account you want to use to proceed:")
        for a in accounts:
            print(a["username"])
        # Assuming the end user chose this one
        chosen = accounts[0]
        # Now let's try to find a token in cache for this account
        result = app.acquire_token_silent(config["scope"], account=chosen)

    if not result:
        logging.info(
            "No suitable token exists in cache. Let's get a new one from AAD.")

        flow = app.initiate_device_flow(scopes=config["scope"])
        if "user_code" not in flow:
            raise ValueError(
                "Fail to create device flow. Err: %s" % json.dumps(flow, indent=4))

        print(flow["message"])
        sys.stdout.flush()  # Some terminal needs this to ensure the message is shown

        # input("Press Enter after signing in from another device to proceed, CTRL+C to abort.")

        result = app.acquire_token_by_device_flow(
            flow)  # By default it will block

    if "access_token" in result:
        #graph_data = requests.get( "https://graph.microsoft.com/v1.0/me", headers={'Authorization': 'Bearer ' + result['access_token']},).json()
        #print("Graph API call result: %s" % json.dumps(graph_data, indent=2))
        me = _me(result)
        nid = _notebook(result, args.notebook)
        if nid:
            if args.create and args.pagename:
                sid = _section(result, nid, args.section)
                if not sid:
                    sid = _createSection(result, nid, args.section)
                
                template = env.get_template(args.pagetemplate)
                body = template.render(title=args.pagename, args=args, me=me)
                pid = _createPage(result, sid, body)
                print("Created: %s" % pid)
            elif args.pid:
                pid=args.pid
                print(pid)
                ids=_pageIds(result, pid)
                if args.dumpids:
                    print(json.dumps(ids, indent=2))
                if args.nmapxml:
                    template = env.get_template(args.nmaptemplate)
                    _nmap(result,pid,_getIdForDataId(ids,"nmap-service-output"),template,args)
                if args.contentid:
                    centent=""
                    if args.contentclip:
                        content=pyperclip.paste()
                        print(content)
                    else:
                        content=args.content
                    _updatePageSection(result,pid,content,_getIdForDataId(ids,args.contentid),"append")            
                if args.pw or args.pwclip:
                    fpw=None
                    if args.pw:
                        fpw=open(args.pw)
                    elif args.pwclip:
                        fpw=io.StringIO(pyperclip.paste())
                    for l in fpw:
                        s=l.split(":")
                        if not args.pwall and int(s[2])<499 and int(s[2])>0:
                            continue
                        print(s[0])
                print(args.updatetblid)
                print(args.updatetbl)
                print(args.matchtbl)
                if args.updatetblid and args.updatetbl and args.matchtbl:
                    t=_getDataIdElement(result,pid,args.updatetblid)
                    _updateRow(t,json.loads(args.matchtbl),json.loads(args.updatetbl))
                    c=lxml.html.tostring(t,encoding="unicode")
                    print(c)
                    print(args.updatetblid)
                    _updatePageSection(result,pid,c ,_getIdForDataId(ids,args.updatetblid),"replace")

                if args.dump:
                    print(_pageContent(result,pid))
    else:
        print(result.get("error"))
        print(result.get("error_description"))
        # You may need this when reporting a bug
        print(result.get("correlation_id"))


if __name__ == "__main__":
    # execute only if run as a script
    main()
