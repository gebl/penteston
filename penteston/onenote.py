import argparse
import atexit
import http.client
import io
import json
import logging
import os
import sys
import time
import webbrowser
import pyperclip

import lxml.html
import msal
import requests
from jinja2 import Environment, FileSystemLoader
from libnmap.parser import NmapParser
from lxml import etree
import html2text

# These two lines enable debugging at httplib level (requests->urllib3->http.client)
# You will see the REQUEST, including HEADERS and DATA, and RESPONSE with HEADERS but without DATA.
# The only thing missing will be the response.body which is not logged.
#try:
#    import http.client as http_client
#except ImportError:
#    # Python 2
#    import httplib as http_client
#http_client.HTTPConnection.debuglevel = 1

# You must initialize logging, otherwise you'll not see debug output.
#logging.basicConfig()
#logging.getLogger().setLevel(logging.DEBUG)
#requests_log = logging.getLogger("requests.packages.urllib3")
#requests_log.setLevel(logging.DEBUG)
#requests_log.propagate = True


class OneNoteAPI:
    auth = None

    def _me(self):
        graph_data = requests.get("https://graph.microsoft.com/v1.0/me",
                                  headers={'Authorization': 'Bearer ' + self.auth['access_token']},).json()
        print("Graph API call result: %s" % json.dumps(graph_data, indent=2))
        return graph_data

    def _notebooks(self):
        graph_data = requests.get("https://graph.microsoft.com/v1.0/me/onenote/notebooks",
                                  headers={'Authorization': 'Bearer ' + self.auth['access_token']},).json()
        res = []
        for i in graph_data['value']:
            res.append((i['displayName'], i['id']))
        return res

    def _notebook(self, notebook):

        graph_data = requests.get("https://graph.microsoft.com/v1.0/me/onenote/notebooks",
                                  headers={'Authorization': 'Bearer ' + self.auth['access_token']},).json()
        for i in graph_data['value']:
            if i['displayName'] == notebook:
                return i['id']
        return None

    def _createSection(self, nid, section):
        r = requests.post("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections" % (nid), headers={
            'Authorization': 'Bearer ' + self.auth['access_token'], 'Content-type': 'application/json'}, data=json.dumps({"displayName": section})).json()
        sectionId = r['id']
        return sectionId

    def _sections(self, nid):
        graph_data2 = requests.get("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections" %
                                   (nid), headers={'Authorization': 'Bearer ' + self.auth['access_token']},).json()
        res = []
        for j in graph_data2['value']:
            res.append((j['displayName'], j['id']))
        return res

    def _section(self, nid, section):
        sectionId = None
        graph_data2 = requests.get("https://graph.microsoft.com/v1.0/me/onenote/notebooks/%s/sections" %
                                   (nid), headers={'Authorization': 'Bearer ' + self.auth['access_token']},).json()
        for j in graph_data2['value']:
            if j['displayName'] == section:
                sectionId = j['id']
        return sectionId

    def _pagesSID(self, sid):
        r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/sections/%s/pages" %
                         (sid), headers={'Authorization': 'Bearer ' + self.auth['access_token']}).json()
        res = []
        for k in r['value']:
            print(k)
            res.append((k['title'], k['id']))
        return res

    def _pages(self, nid, section):
        sid = self._section(nid, section)
        return self._pagesSID(sid)

    def _page(self, sid, page):
        pageId = None
        r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/sections/%s/pages" %
                         (sid), headers={'Authorization': 'Bearer ' + self.auth['access_token']}).json()
        for k in r['value']:
            if k['title'] == page:
                pageId = k['id']
        return pageId

    def _createPage(self, sid, body):
        r = requests.post("https://graph.microsoft.com/v1.0/me/onenote/sections/%s/pages" % (sid), headers={
            'Authorization': 'Bearer ' + self.auth['access_token']}, files={'Presentation': (None, body, 'text/html')}).json()
        print(r)
        for i in range(0, 100):
            r2 = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true" %
                              (r['id']), headers={'Authorization': 'Bearer ' + self.auth['access_token']}).text
            if not "The specified resource ID does not exist." in r2:
                break
            time.sleep(5)
        return r['id']

    def _getDataIdElement(self, pid, id):
        r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true" %
                         (pid), headers={'Authorization': 'Bearer ' + self.auth['access_token']}).text
        root = etree.fromstring(r)
        return root.find('.//*[@data-id="%s"]' % id)

    def _getDataIdMarkdown(self,pid,id):
        e=self._getDataIdElement(pid,id)
        if e is not None:
            return html2text.html2text(etree.tostring(e, encoding='unicode'))
        else:
            return ""
        
    def _tableColumns(self, t):
        cols = []
        for c in t[0]:
            cols.append(c[0].text)
        return cols

    def _rowJson(self, cols, tr):
        row = {}
        for i in range(0, len(cols)):
            row[cols[i]] = tr[i].text
        return row

    def _rowUpdate(self, cols, tr, n):
        for i in range(0, len(cols)):
            row[cols[i]] = tr[i].text
        return row

    def _rowIndex(self, t, m):
        res = []
        cols = _tableColumns(t)
        for i in range(1, len(t)):
            r = _rowJson(cols, t[i])
            rowmatch = True
            for k in m:
                rowmatch = rowmatch and (r[k] == m[k])
            if rowmatch:
                res.append(i)
        return res

    def _updateRow(self, t, m, n):
        ris = _rowIndex(t, m)
        print(ris)
        cols = _tableColumns(t)
        print(cols)
        for r in ris:
            for k in n:
                print(k)
                t[r][cols.index(k)].text = n[k]

    def _tableJson(self, t):
        json = []
        cols = _tableColumns(t)
        for r in t[1:]:
            json.append(_rowJson(cols, r))
        return json

    def _pageIds(self, pid):
        r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content?includeIDs=true" %
                         (pid), headers={'Authorization': 'Bearer ' + self.auth['access_token']}).text
        root = etree.fromstring(r)
        dataids = []
        for e in root.findall('.//*[@data-id]'):
            if e.get("id"):
                dataids.append((e.get("id"), e.get("data-id")))
        return dataids

    def _pageContent(self, pid):
        r = requests.get("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content" %
                         (pid), headers={'Authorization': 'Bearer ' + self.auth['access_token']}).text
        return r

    def _getIdForDataId(self, dataids, dataid):
        for d in dataids:
            if d[1] == dataid:
                return d[0]
        return None

    def _updatePageSection(self, pid, content, dataId, action):
        data = json.dumps(
            [{"target": dataId, "action": action, "content": content}])
        r = requests.patch("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content" % (pid), headers={
            'Authorization': 'Bearer ' + self.auth['access_token'], 'Content-type': 'application/json'}, data=data).text
        print(r)

    def _updateImgMultipart(self, pid, dataId, action, bcontent, acontent, imgbytes):
        content = bcontent+'<img src="name:image-part-name" />'+acontent
        data = json.dumps(
            [{"target": dataId, "action": action, "content": content}])
        r = requests.patch("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content" % (pid), headers={
            'Authorization': 'Bearer ' + self.auth['access_token']}, files={'Commands': (None, data, 'application/json'), 'image-part-name': (None, imgbytes, 'image/png')}).text
        print("result:")
        print(r)

    def _updateFileMultipart(self, pid, dataId, action, bcontent, acontent, name, mimetype, mbytes):
        # https://docs.microsoft.com/en-us/graph/onenote-images-files
        content = '<object data-attachement="%s" data="name:content-block-name" type="%s" />' % (
            name, mimetype)

        data = json.dumps(
            [{"target": dataId, "action": action, "content": content}])
        r = requests.patch("https://graph.microsoft.com/v1.0/me/onenote/pages/%s/content" % (pid), headers={
            'Authorization': 'Bearer ' + self.auth['access_token']}, files={'Commands': (None, data, 'application/json'), 'content-block-name': (name, mbytes, mimetype)}).text
        print(content)
        print(data)
        print("result:")
        print(r)

    def _nmap(self, pid, oid, roid, template, atemplate, btemplate, nmapxml):
        report = NmapParser.parse_fromfile(nmapxml)
        content = template.render(report=report)
        acontent = atemplate.render(report=report)
        bcontent = btemplate.render(report=report)
        self._updatePageSection(pid, content, oid, "replace")
        if roid:
            self._updateFileMultipart(
                pid, roid, "append", bcontent, acontent, "nmap.txt", "text/plain", open(nmapxml))

    def _createRow(self, items):
        tr = Element("tr")

    def _auth(self, clientid, authority, scope):
        cache = msal.SerializableTokenCache()

        if os.path.exists("my_cache.bin"):
            cache.deserialize(open("my_cache.bin", "r").read())
        atexit.register(lambda:
                        open("my_cache.bin", "w").write(cache.serialize()
                                                        ) if cache.has_state_changed else None
                        )

        # Optional logging
        # logging.basicConfig(level=logging.DEBUG)

        # Create a preferably long-lived app instance which maintains a token cache.
        app = msal.PublicClientApplication(
            clientid, authority=authority,
            token_cache=cache
        )

        accounts = app.get_accounts()
        if accounts:
            logging.info(
                "Account(s) exists in cache, probably with token too. Let's try.")
            print("Pick the account you want to use to proceed:")
            for a in accounts:
                print(a["username"])
            # Assuming the end user chose this one
            chosen = accounts[0]
            # Now let's try to find a token in cache for this account
            self.auth = app.acquire_token_silent(scope, account=chosen)

        if not self.auth:
            logging.info(
                "No suitable token exists in cache. Let's get a new one from AAD.")

            flow = app.initiate_device_flow(scopes=scope)
            if "user_code" not in flow:
                raise ValueError(
                    "Fail to create device flow. Err: %s" % json.dumps(flow, indent=4))

            webbrowser.open(flow['verification_uri'])
            sys.stdout.flush()  # Some terminal needs this to ensure the message is shown
            pyperclip.copy(flow['user_code'])
            print("Device Code: %s",flow['user_code'])
            # input("Press Enter after signing in from another device to proceed, CTRL+C to abort.")

            self.auth = app.acquire_token_by_device_flow(
                flow)  # By default it will block
        return "access_token" in self.auth
